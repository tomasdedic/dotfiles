{

"Azure CLI": {
"prefix": "adoAzureCLI2",
"body": [
"- task: AzureCLI@2",
"  inputs:",
"    connectedServiceNameARM: $1  # Required  # Select an Azure Resource Manager service connection for the deployment",
"    scriptType: $2 # Options: 'ps', 'pscore', 'batch', 'bash' # Required  # Type of script: PowerShell/PowerShell Core/Bat/Shell script. Select Shell/PowerShell Core script when running on Linux agent or Batch/PowerShell/PowerShell Core script when running on Windows agent. PowerShell Core script can run on cross-platform agents (Linux, macOS, or Windows).",
"    scriptLocation: ${3:scriptPath} # Options: 'inlineScript', 'scriptPath' # Required  # Path to script: File path or Inline script",
"    scriptPath: $4  # Required when scriptLocation = scriptPath  # Fully qualified path of the script(.ps1 or .bat or .cmd when using Windows based agent else .ps1 or .sh when using linux based agent) or a path relative to the the default working directory",
"    inlineScript: $5  # Required when scriptLocation = inlineScript  # You can write your scripts inline here. When using Windows agent, use PowerShell or PowerShell Core or batch scripting whereas use PowerShell Core or shell scripting when using Linux based agents. For batch files use the prefix \"call\" before every azure command. You can also pass predefined and custom variables to this script using arguments  example for PowerShell/PowerShellCore/shell: az --version az account show  example for batch:call  az --version call az account show",
"    #scriptArguments:  # Optional  # Arguments passed to the script",
"    #powerShellErrorActionPreference: # Options: 'stop', 'continue', 'silentlyContinue' # Optional  # Prepends the line `$ErrorActionPreference = 'VALUE'` at the top of your powershell/powershell core script.",
"    #addSpnToEnvironment:  # Optional  # Adds service principal id, service principal key and tenant id of the Azure endpoint you chose to the script's execution environment. You can use variables: `servicePrincipalId`, `servicePrincipalKey` and `tenantId` in your script.This is honored only when the Azure endpoint has Service Principal authentication scheme.Syntax to access environment variables based on script type.Powershell script: $env:servicePrincipalIdBatch script: %servicePrincipalId% Shell script: $servicePrincipalId",
"    #useGlobalConfig:  # Optional  # If this is false, this task will use its own separate [Azure CLI configuration directory](https://docs.microsoft.com/en-us/cli/azure/azure-cli-configuration?view=azure-cli-latest#cli-configuration-file). This can be used to run Azure CLI tasks in *parallel* releases",
"    #cwd:  # Optional  # Current working directory where the script is run.  Empty is the root of the repo (build) or artifacts (release), which is \\$(System.DefaultWorkingDirectory)",
"    #failOnStandardError:  # Optional  # If this is true, this task will fail when any errors are written to the StandardError stream. Unselect the checkbox to ignore standard errors and rely on exit codes to determine the status",
"    #powerShellIgnoreLASTEXITCODE:  # Optional  # If this is false, the line `if ((Test-Path -LiteralPath variable:/\/LASTEXITCODE)) { exit $LASTEXITCODE }` is appended to the end of your script. This will cause the last exit code from an external command to be propagated as the exit code of powershell. Otherwise the line is not appended to the end of your script.",
"$6"
],
"description": "Run Azure CLI commands against an Azure subscription in a PowerShell Core/Shell script when running on Linux agent or PowerShell/PowerShell Core/Batch script when running on Windows agent."
},

"Download build artifacts": {
"prefix": "adoDownloadBuildArtifacts1",
"body": [
"- task: DownloadBuildArtifacts@1",
"  inputs:",
"    buildType: ${1:current} # Options: 'current', 'specific' # Required  # Download artifacts produced by the current build, or from a specific build.",
"    project: $2  # Required when buildType == specific  # The project from which to download the build artifacts",
"    definition: $3  # Required when buildType == specific  # Select the build pipeline name",
"    #specificBuildWithTriggering:  # Optional  # If checked, this build task will try to download artifacts from the triggering build. If there is no triggering build from the specified pipeline, it will download artifacts from the build specified in the options below.",
"    buildVersionToDownload: ${4:latest} # Options: 'latest', 'latestFromBranch', 'specific' # Required ",
"    #allowPartiallySucceededBuilds:  # Optional  # If checked, this build task will try to download artifacts whether the build is succeeded or partially succeeded.",
"    branchName: ${5:refs/heads/master}  # Required  # Specify to filter on branch/ref name, for example: ```refs/heads/develop```.",
"    buildId: $6  # Required when buildType == specific && buildVersionToDownload == specific  # The build from which to download the artifacts",
"    #tags:  # Optional  # A comma-delimited list of tags. Only builds with these tags will be returned.",
"    downloadType: ${7:single} # Options: 'single', 'specific' # Required  # Download a specific artifact or specific files from the build.",
"    artifactName: $8  # Required when downloadType == single  # The name of the artifact to download",
"    #itemPattern:  # Optional  # Specify files to be downloaded as multi line minimatch pattern. [More Information](https://aka.ms/minimatchexamples) <p>The default pattern (/\/*/\/*) will download all files across all artifacts in the build if \"Specific files\" option is selected. To download all files within artifact drop use drop/**.</p>",
"    downloadPath: ${9:$(System.ArtifactsDirectory)}  # Required  # Path on the agent machine where the artifacts will be downloaded",
"    #cleanDestinationFolder:  # Optional  # Delete all existing files in destination folder before artifact download",
"    #parallelizationLimit:  # Optional  # Number of files to download simultaneously",
"    #checkDownloadedFiles:  # Optional  # If checked, this build task will check that all files are fully downloaded.",
"    #retryDownloadCount:  # Optional  # Optional number of times to retry downloading a build artifact if the download fails.",
"    #extractTars:  # Optional  # Enable this option to extract all downloaded files that have .tar extension. This is helpful because you need to pack your artifact files into tar if you want to preserve Unix file permissions. Enabling `StoreAsTar` option in PublishBuildArtifacts task will store artifacts as .tar files automatically.",
"$10"
],
"description": "Download files that were saved as artifacts of a completed build"
},
"Package and deploy Helm charts": {
"prefix": "adoHelmDeploy0",
"body": [
"- task: HelmDeploy@0",
"  inputs:",
"    connectionType: ${1:Azure Resource Manager} # Options: 'Azure Resource Manager', 'Kubernetes Service Connection', 'None' # Required  # Select 'Azure Resource Manager' to connect to an Azure Kubernetes Service by using Azure Service Connection. Select 'Kubernetes Service Connection' to connect to any Kubernetes cluster by using kubeconfig or Service Account",
"    azureSubscriptionEndpoint: $2  # Required when connectionType = Azure Resource Manager  # Select an Azure subscription, which has your Azure Container Registry.",
"    azureResourceGroup: $3  # Required when connectionType = Azure Resource Manager  # Select an Azure Resource Group.",
"    kubernetesCluster: $4  # Required when connectionType = Azure Resource Manager  # Select an Azure Managed Cluster.",
"    #useClusterAdmin:  # Optional  # Use cluster administrator credentials instead of default cluster user credentials.",
"    kubernetesServiceEndpoint: $5  # Required when connectionType = Kubernetes Service Connection  # Select a Kubernetes service connection.",
"    #namespace:  # Optional  # Specify K8 namespace to use. Use Tiller namespace can be specified in the advanced section of the task or by passing the --tiller-namespace option as argument.",
"    azureSubscriptionEndpointForACR: $6  # Required  # Select an Azure subscription, which has your Azure Container Registry.",
"    azureResourceGroupForACR: $7  # Required  # Select an Azure Resource Group, which has your Container Registry.",
"    azureContainerRegistry: $8  # Required  # Select an Azure Container Registry which will be used for pushing helm charts.",
"    command: ${9:ls} # Options: 'create', 'delete', 'expose', 'get', 'init', 'install', 'login', 'logout', 'ls', 'package', 'rollback', 'save', 'upgrade', 'uninstall' # Required  # Select a helm command.",
"    chartType: ${10:Name} # Options: 'Name', 'FilePath' # Required  # Select how you want to enter chart info. You can either provide name of the chart or folder/file path to the chart.",
"    chartName: $11  # Required when chartType == Name  # Chart reference to install, this can be a url or a chart name. For example, if chart name is 'stable/mysql', the task will run 'helm install stable/mysql'.",
"    chartPath: $12  # Required when chartType == FilePath || command == package  # Path to the chart to install. This can be a path to a packaged chart or a path to an unpacked chart directory. For example, if './redis' is specified the task will run 'helm install ./redis'.",
"    #version:  # Optional  # Specify the exact chart version to install. If this is not specified, the latest version is installed. Set the version on the chart to this semver version​",
"    #releaseName:  # Optional  # Release name. If unspecified, it will autogenerate one for you.",
"    #overrideValues:  # Optional  # Set values on the command line (can specify multiple or separate values with commas or newlines: key1=val1,key2=val2 or <br>key1=val1<br>key2=val2<br>). The task will construct the helm command by using these set values. For example, helm install --set key1=val1 ./redis.",
"    #valueFile:  # Optional  # Specify values in a YAML file or a URL. For example, specifying myvalues.yaml will result in 'helm install --values=myvals.yaml'.",
"    #destination:  # Optional  # Specify values in a YAML file or a URL.",
"    #canaryimage:  # Optional  # Use the canary Tiller image, the latest pre-release version of Tiller.",
"    #upgradetiller:  # Optional  # Upgrade if Tiller is already installed.",
"    #updatedependency:  # Optional  # Run helm dependency update before installing the chart. Update dependencies from 'requirements.yaml' to dir 'charts/' before packaging",
"    #save:  # Optional  # Save packaged chart to local chart repository (default true)​",
"    #install:  # Optional  # If a release by this name doesn't already exist, run an install​.",
"    #recreate:  # Optional  # Performs pods restart for the resource if applicable.",
"    #resetValues:  # Optional  # Reset the values to the ones built into the chart.",
"    #force:  # Optional  # Force resource update through delete/recreate if needed​",
"    #waitForExecution:  # Optional  # Block till command execution completes.",
"    #arguments:  # Optional  # Helm command options.",
"    #enableTls:  # Optional  # Enables using SSL between Helm and Tiller.",
"    caCert: $13  # Required when enableTls == true  # CA cert used to issue certificate for tiller and helm client.",
"    certificate: $14  # Required when enableTls == true  # Specify Tiller certificate or Helm client certificate",
"    privatekey: $15  # Required when enableTls == true  # Specify Tiller Key or Helm client key",
"    #tillernamespace:  # Optional  # Specify K8 namespace of tiller.",
"    #failOnStderr:  # Optional  # If this is true, this task will fail if any errors are written to the error pipeline, or if any data is written to the Standard Error stream. Otherwise the task will rely on the exit code to determine failure.",
"    #publishPipelineMetadata:  # Optional  # If this is true, the task will collect and publish deployment metadata",
"    chartNameForACR: $16  # Required when command == save  # Chart name with which the chart will be stored in Azure Container Registry.",
"    chartPathForACR: $17  # Required when command == save  # Path to the chart directory.",
"$18"
],
"description": "Deploy, configure, update a Kubernetes cluster in Azure Container Service by running helm commands"
},

"Bash": {
"prefix": "adoBash3",
"body": [
"- task: Bash@3",
"  inputs:",
"    #targetType: # Options: 'filePath', 'inline' # Optional  # Target script type: File Path or Inline",
"    filePath: $1  # Required when targetType = filePath  # Path of the script to execute. Must be a fully qualified path or relative to (System.DefaultWorkingDirectory).",
"    #arguments:  # Optional  # Arguments passed to the shell script. Either ordinal parameters or named parameters.",
"    script: ${2:# Write your commands hereecho 'Hello world'}  # Required ",
"    #workingDirectory:  # Optional ",
"    #failOnStderr:  # Optional  # If this is true, this task will fail if any errors are written to the StandardError stream.",
"    #bashEnvValue:  # Optional  # If input is specified, it's value is expanded and used as the path of a startup file to execute before running the script. If the environment variable `BASH_ENV` has already been defined, the task will override this variable only for the current task. You can find more details by [link](https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html).",
"$3"
],
"description": "Run a Bash script "
},

    "mustache": {
      "description": "Mustache filetype",
      "body": [
        "{{/* vim: set filetype=mustache: */}}"
      ],
      "prefix": [
        "mus"
      ]
    },
    "helm": {
      "description": "Mustache filetype",
      "body": [
        "{{/* vim: set filetype=helm: */}}"
      ],
      "prefix": [
        "helm"
      ]
    },
    "sa": {
        "description": "ServiceAccount",
        "body": [
            "apiVersion: v1",
            "kind: ServiceAccount",
            "metadata:",
            "\tname: ${1:name}"
        ],
        "prefix": [
            "sa"
        ]
    },
    "probe": {
        "description": "Liveness/Readiness Probes",
        "body": [
            "livenessProbe: &probe",
            "\tinitialDelaySeconds: ${1:10}",
            "\thttpGet:",
            "\t\tport: ${2:8080}",
            "\t\tpath: ${3:/}",
            "readinessProbe: *probe $0"
        ],
        "prefix": [
            "probe"
        ]
    },
    "cert": {
        "description": "cert-manager certificate",
        "body": [
            "apiVersion: certmanager.k8s.io/v1alpha1",
            "kind: Certificate",
            "metadata:",
            "\tname: ${1:name}",
            "\tnamespace: ${2:namespace}",
            "spec:",
            "\tsecretName: ${4:$3.tls}",
            "\tdnsNames:",
            "\t- ${3:some.domain.com}",
            "\tacme:",
            "\t\tconfig:",
            "\t\t- dns01:",
            "\t\t\t\tprovider: ${4:prod}",
            "\t\t\tdomains: [ $3 ]",
            "\tissuerRef:",
            "\t\tname: ${5:letsencrypt}",
            "\t\tkind: ClusterIssuer"
        ],
        "prefix": [
            "cert"
        ]
    },
    "pvol": {
        "description": "Pod Volume Object",
        "body": [
            "- name: ${1:name}",
            "\t${2:source}:",
            "\t\tname:"
        ],
        "prefix": [
            "pvol"
        ]
    },
    "init": {
        "description": "Init Container",
        "body": [
            "initContainers:",
            "- name: ${1:myinit}",
            "\timage: ${2:busybox}",
            "\tcommand: [${3:rm, -rf,  $5/lost+found}]",
            "\t${6:volumeMounts:",
            "\t- name: ${4:data}",
            "\t\tmountPath: ${5:/data}}$0"
        ],
        "prefix": [
            "init"
        ]
    },
    "kss": {
        "description": "test",
        "body": [
            "dsadasdas"
        ],
        "prefix": [
            "kss"
        ]
    },
    "job": {
        "description": "Kubernetes Job",
        "body": [
            "apiVersion: batch/v1",
            "kind: Job",
            "metadata:",
            "\tname: ${1:jobname}",
            "\tlabels:",
            "\t\t${2:sometag: somevalue}",
            "spec:",
            "\ttemplate:",
            "\t\tmetadata:",
            "\t\t\tname: $1",
            "\t\tspec:",
            "\t\t\tcontainers:",
            "\t\t\t- name: ${3:containerName}",
            "\t\t\t\timage: ${4: image}",
            "\t\t\t\timagePullPolicy: Always",
            "\t\t\t\tcommand:",
            "\t\t\t\t- ${5:\"override\"",
            "\t\t\t\t- \"--the\"",
            "\t\t\t\t- \"entrypoint\"}",
            "\t\t\trestartPolicy: OnFailure"
        ],
        "prefix": [
            "job"
        ]
    },
    "svc": {
        "description": "Service",
        "body": [
            "apiVersion: v1",
            "kind: Service",
            "metadata:",
            "\tname: ${1:frontend}",
            "\tnamespace: ${2:default}",
            "\tlabels:",
            "\t\tapp: ${3:someApp}",
            "\t\ttier: ${4:frontend}",
            "spec:",
            "\tports:",
            "\t- port: ${5:80}",
            "\tselector:",
            "\t\tapp: $3",
            "\t\ttier: $4"
        ],
        "prefix": [
            "svc"
        ]
    },
    "prom": {
        "description": "Prometheus annotations",
        "body": [
            "annotations:",
            "\tprometheus.io/scrape: \"true\"",
            "\tprometheus.io/endpoint: \"${1:/metrics}\"",
            "\tprometheus.io/port: \"${2:8080}\""
        ],
        "prefix": [
            "prom"
        ]
    },
    "strat": {
        "description": "Deployment Strategy",
        "body": [
            "strategy:",
            "\ttype: ${1:RollingUpdate|Recreate}",
            "\trollingUpdate:",
            "\t\tmaxSurge: ${2:1}",
            "\t\tmaxUnavailable: ${3:1}$0"
        ],
        "prefix": [
            "strat"
        ]
    },
    "edns": {
        "description": "external dns",
        "body": [
            "annotations:",
            "\texternal-dns.alpha.kubernetes.io/hostname: ${1:myname.mydomain.com}"
        ],
        "prefix": [
            "edns"
        ]
    },
    "dep": {
        "description": "Deployment",
        "body": [
            "apiVersion: apps/v1",
            "kind: Deployment",
            "metadata:",
            "\tname: ${1:some-controller}",
            "\tnamespace: ${2:default}",
            "spec:",
            "\treplicas: 1",
            "\tselector:",
            "\t\tmatchLabels:",
            "\t\t\t$3",
            "\ttemplate:",
            "\t\tmetadata:",
            "\t\t\tlabels:",
            "\t\t\t\t${3:app: $1}",
            "\t\tspec:",
            "\t\t\tcontainers:",
            "\t\t\t- name: ${4:name}",
            "\t\t\t\timage: ${5:nginx}",
            "\t\t\t\timagePullPolicy: Always",
            "\t\t\t\tresources:",
            "\t\t\t\t\trequests:",
            "\t\t\t\t\t\tcpu: 100m",
            "\t\t\t\t\t\tmemory: 200Mi",
            "\t\t\t\tports:",
            "\t\t\t\t- containerPort: 8080"
        ],
        "prefix": [
            "dep"
        ]
    },
    "cfg": {
        "description": "ConfigMap",
        "body": [
            "apiVersion: v1",
            "kind: ConfigMap",
            "metadata:",
            "\tname: ${1:name}",
            "data:",
            "\t${2:key}: ${3:value}"
        ],
        "prefix": [
            "cfg"
        ]
    },
    "cron": {
        "description": "Kubernetes Cronjob",
        "body": [
            "apiVersion: batch/v2alpha1",
            "kind: CronJob",
            "metadata:",
            "\tname: ${1:name}",
            "spec:",
            "\tschedule: \"${2:*/1} * * * *\"",
            "\tjobTemplate:",
            "\t\tspec:",
            "\t\t\ttemplate:",
            "\t\t\t\tspec:",
            "\t\t\t\t\tcontainers:",
            "\t\t\t\t\t- name: $1",
            "\t\t\t\t\t\timage: ${3: image}",
            "\t\t\t\t\t\targs: ${4:",
            "\t\t\t\t\t\t- /bin/sh",
            "\t\t\t\t\t\t- -c",
            "\t\t\t\t\t\t- date; echo Hello from the Kubernetes cluster}",
            "\t\t\t\t\trestartPolicy: OnFailure"
        ],
        "prefix": [
            "cron"
        ]
    },
    "ing": {
        "description": "Ingress",
        "body": [
            "apiVersion: extensions/v1beta1",
            "kind: Ingress",
            "metadata:",
            "\tname: ${1:name}",
            "\tnamespace: ${2:default}",
            "annotations:",
            "\tcert-manager.io/cluster-issuer: letsencrypt-prod",
            "\tkubernetes.io/ingress.class: nginx-external",
            "\tkubernetes.io/tls-acme: \"true\"",
            "\tnginx.ingress.kubernetes.io/ssl-passthrough: \"false\"",
            "spec:",
            "\t${5:tls:",
            "\t- secretName: ${4:$3.tls}",
            "\t\thosts:",
            "\t\t- $3",
            "\t}rules:",
            "\t- host: ${3:host.tld}",
            "\t\thttp:",
            "\t\t\tpaths:",
            "\t\t\t- path: ${7:/}",
            "\t\t\t\tbackend:",
            "\t\t\t\t\tserviceName: ${8:service}",
            "\t\t\t\t\tservicePort: ${9:portNumberOrName}"
        ],
        "prefix": [
            "ing"
        ]
    },
    "env": {
        "description": "Environment template",
        "body": [
            "- name: ${1:VAR_NAME}",
            "  value: ${2:value}"
        ],
        "prefix": [
            "env"
        ]
    },
    "ns": {
        "description": "Namespace",
        "body": [
            "apiVersion: v1",
            "kind: Namespace",
            "metadata:",
            "\tname: ${1:name}"
        ],
        "prefix": [
            "ns"
        ]
    },
    "secref": {
        "description": "env SecretRef",
        "body": [
            "valueFrom:",
            "\tsecretKeyRef:",
            "\t\tname: ${1:secret-name}",
            "\t\tkey: ${2:key-name}"
        ],
        "prefix": [
            "secref"
        ]
    },
    "rc": {
        "description": "Replication Controller",
        "body": [
            "# WARNING, use Deployments -- ReplicationController is being replaced.",
            "apiVersion: v1",
            "kind: ReplicationController",
            "metadata:",
            "\tname: ${1:some-controller}",
            "\tnamespace: ${2:default}",
            "spec:",
            "\treplicas: 1",
            "\ttemplate:",
            "\t\tmetadata:",
            "\t\t\tlabels:",
            "\t\t\t\tapp: $1",
            "\t\t\t\ttier: $3",
            "\t\tspec:",
            "\t\t\tcontainers:",
            "\t\t\t- name: ${4:name}",
            "\t\t\t\timage: ${5:nginx}",
            "\t\t\t\timagePullPolicy: Always",
            "\t\t\t\tresources:",
            "\t\t\t\t\trequests:",
            "\t\t\t\t\t\tcpu: 100m",
            "\t\t\t\t\t\tmemory: 200Mi",
            "\t\t\t\tports:",
            "\t\t\t\t- containerPort: 8080"
        ],
        "prefix": [
            "rc"
        ]
    },
    "atls": {
        "description": "tls-acme annotations",
        "body": [
            "annotations:",
            "\tkubernetes.io/tls-acme: \"true\""
        ],
        "prefix": [
            "atls"
        ]
    },
    "pvc": {
        "description": "PersistentVolumeClaim",
        "body": [
            "apiVersion: v1",
            "kind: PersistentVolumeClaim",
            "metadata:",
            "\tname: ${1:name}",
            "\tlabels:",
            "\t\t# insert any desired labels to identify your claim",
            "\t\tapp: ${2:app}",
            "\t\ttier: ${3:tier}",
            "spec:",
            "\t${4:storageClassName: ${5:standard}}",
            "\taccessModes:",
            "\t\t- ${6:ReadWriteOnce}",
            "\tresources:",
            "\t\trequests:",
            "\t\t\t# The amount of the volume's storage to request",
            "\t\t\tstorage: ${7:20Gi}"
        ],
        "prefix": [
            "pvc"
        ]
    },
    "rbac": {
        "description": "Role and Binding",
        "body": [
            "kind: ${1:Cluster}Role",
            "apiVersion: rbac.authorization.k8s.io/v1",
            "metadata:",
            "\t${2:namespace: ${3:default}",
            "\t}name: ${4:configmap-updater}",
            "rules:",
            "- apiGroups: [\"${5:}\"]",
            "\tresources: [\"${6:configmaps}\"]",
            "\tresourceNames: [\"${7:my-configmap}\"]",
            "\tverbs: [${8:\"update\", \"get\"}]",
            "---",
            "# This role binding allows \"jane\" to read pods in the \"default\" namespace.",
            "kind: ${9:Cluster}RoleBinding",
            "apiVersion: rbac.authorization.k8s.io/v1",
            "metadata:",
            "\tname: $4",
            "\t$2",
            "subjects:",
            "- kind: ${10:User|ServiceAccount|Group}",
            "\tname: ${11:jane} # Name is case sensitive",
            "\tapiGroup: rbac.authorization.k8s.io",
            "roleRef:",
            "\tkind: $1Role #this must be Role or ClusterRole",
            "\tname: $4 # this must match the name of the Role or ClusterRole you wish to bind to",
            "\tapiGroup: rbac.authorization.k8s.io"
        ],
        "prefix": [
            "rbac"
        ]
    },
    "depsvc": {
        "description": "Deployment and service",
        "body": [
            "apiVersion: apps/v1",
            "kind: Deployment",
            "metadata:",
            "\tname: ${1:some-controller}",
            "\tnamespace: ${2:default}",
            "spec:",
            "\treplicas: 1",
            "\tselector:",
            "\t\tmatchLabels:",
            "\t\t\t$3",
            "\ttemplate:",
            "\t\tmetadata:",
            "\t\t\tlabels:",
            "\t\t\t\t${3:app: $1}",
            "\t\tspec:",
            "\t\t\tcontainers:",
            "\t\t\t- name: ${4:name}",
            "\t\t\t\timage: ${5:nginx}",
            "\t\t\t\timagePullPolicy: Always",
            "\t\t\t\tresources:",
            "\t\t\t\t\trequests:",
            "\t\t\t\t\t\tcpu: 100m",
            "\t\t\t\t\t\tmemory: 200Mi",
            "\t\t\t\tports:",
            "\t\t\t\t- containerPort: ${6:8080}",
            "---",
            "apiVersion: v1",
            "kind: Service",
            "metadata:",
            "\tname: $1",
            "\tnamespace: $2",
            "spec:",
            "\tports:",
            "\t- port: ${7:80}",
            "\t\ttargetPort: $6",
            "\tselector:",
            "\t\t$3"
        ],
        "prefix": [
            "depsvc"
        ]
    },
    "pv": {
        "description": "PersistentVolume",
        "body": [
            "apiVersion: v1",
            "kind: PersistentVolume",
            "metadata:",
            "\tname: ${1:name}",
            "\tlabels:",
            "\t\tapp: ${2:app}",
            "\t\ttier: ${3:tier}",
            "spec:",
            "\tcapacity:",
            "\t\tstorage: ${4:20Gi}",
            "\taccessModes:",
            "\t\t- ${5:ReadWriteMany}",
            "\tnfs:",
            "\t\tserver: ${6:NameOrIP}",
            "\t\tpath: ${7:\"/share/path/on/server\"}"
        ],
        "prefix": [
            "pv"
        ]
    },
    "skr": {
        "description": "SecretKeyRef",
        "body": [
            "valueFrom:",
            "\tsecretKeyRef:",
            "\t\tname: ${1:secret}",
            "\t\tkey: ${2:key}"
        ],
        "prefix": [
            "skr"
        ]
    },
    "rb": {
        "description": "RoleBinding",
        "body": [
            "# This role binding allows \"jane\" to read pods in the \"default\" namespace.",
            "kind: ${1:Cluster}RoleBinding",
            "apiVersion: rbac.authorization.k8s.io/v1",
            "metadata:",
            "\tname: ${2:read-pods}",
            "\t${3:namespace: ${4:pods}",
            "}subjects:",
            "- kind: ${5:User|ServiceAccount|Group}",
            "\tname: ${6:jane} # Name is case sensitive",
            "\tapiGroup: rbac.authorization.k8s.io",
            "roleRef:",
            "\tkind: ${7:Cluster}Role #this must be Role or ClusterRole",
            "\tname: ${8:pod-reader} # this must match the name of the Role or ClusterRole you wish to bind to",
            "\tapiGroup: rbac.authorization.k8s.io"
        ],
        "prefix": [
            "rb"
        ]
    },
    "ks": {
        "description": "Kustomization-secretgenerator",
        "body": [
            "apiVersion: kustomize.config.k8s.io/v1beta1",
            "kind: Kustomization",
            "",
            "generatorOptions:",
            "\tdisableNameSuffixHash: true",
            "secretGenerator:",
            "- name: db-user-pass",
            "\tliterals:",
            "\t- username=admin",
            "\t- password=1f2d1e2e67df",
            "- name: gcr-pull",
            "\ttype: kubernetes.io/dockerconfigjson",
            "\tfiles:",
            "\t\t- .dockerconfigjson=config.json"
        ],
        "prefix": [
            "ks"
        ]
    },
    "netp": {
        "description": "NetworkPolicy",
        "body": [
            "kind: NetworkPolicy",
            "apiVersion: extensions/v1beta1",
            "metadata:",
            "\tnamespace: ${1:default}",
            "\tname: ${2:policyname}",
            "\tspec:",
            "\t${4:podSelector:",
            "\t\t\tmatchLabels:",
            "\t\t\t\t${3:{}}",
            "}\tingress:",
            "\t\t\t- {}"
        ],
        "prefix": [
            "netp"
        ]
    },
    "ku": {
        "description": "Kustomization",
        "body": [
            "apiVersion: kustomize.config.k8s.io/v1beta1",
            "kind: Kustomization",
            "",
            "resources:",
            "- ${1:some-resource-yaml}"
        ],
        "prefix": [
            "ku"
        ]
    },
    "ss": {
        "description": "StatefulSet",
        "body": [
            "apiVersion: v1",
            "kind: Service",
            "metadata:",
            "\tname: ${1:myservice}",
            "spec:",
            "\tports:",
            "\t- port: $5",
            "\t\tname: $6",
            "\tclusterIP: None",
            "\tselector:",
            "\t\t$2",
            "---",
            "apiVersion: apps/v1",
            "kind: StatefulSet",
            "metadata:",
            "\tname: ${1:mystatefulset}",
            "spec:",
            "\tselector:",
            "\t\tmatchLabels:",
            "\t\t\t$2",
            "\tserviceName: \"nginx\"",
            "\treplicas: 3 # by default is 1",
            "\ttemplate:",
            "\t\tmetadata:",
            "\t\t\tlabels:",
            "\t\t\t\t${2:app: $1}",
            "\t\tspec:",
            "\t\t\t# terminationGracePeriodSeconds: 10",
            "\t\t\tcontainers:",
            "\t\t\t- name: ${3:$1}",
            "\t\t\t\timage: ${4:$1}",
            "\t\t\t\tports:",
            "\t\t\t\t- containerPort: ${5:80}",
            "\t\t\t\t\tname: ${6:web}",
            "\t\t\t\tvolumeMounts:",
            "\t\t\t\t- name: ${7:volume}",
            "\t\t\t\t\tmountPath: ${8:/var/lib/mydata}",
            "\tvolumeClaimTemplates:",
            "\t- metadata:",
            "\t\t\tname: $7",
            "\t\tspec:",
            "\t\t\taccessModes: [ \"ReadWriteOnce\" ]",
            "\t\t\tstorageClassName: \"${9:standard}\"",
            "\t\t\tresources:",
            "\t\t\t\trequests:",
            "\t\t\t\t\tstorage: ${10:1G}"
        ],
        "prefix": [
            "ss"
        ]
    },
    "res": {
        "description": "Resources",
        "body": [
            "resources:",
            "\trequests:",
            "\t\tcpu: ${1:100m}",
            "\t\tmemory: ${2:200Mi}",
            "\t${5:limits:",
            "\t\tcpu: ${3:$1}",
            "\t\tmemory: ${4:$2}}$0"
        ],
        "prefix": [
            "res"
        ]
    },
    "cmtls": {
        "description": "cert-manager tls annotations",
        "body": [
            "${2:annotations:",
            "\t}certmanager.k8s.io/cluster-issuer: ${1:lets-encrypt}"
        ],
        "prefix": [
            "cmtls"
        ]
    },
    "vtls": {
        "description": "tls-vault annotations",
        "body": [
            "annotations:",
            "\tkubernetes.io/tls-vault: \"true\""
        ],
        "prefix": [
            "vtls"
        ]
    },
    "role": {
        "description": "Role",
        "body": [
            "kind: ${1:Cluster}Role",
            "apiVersion: rbac.authorization.k8s.io/v1",
            "metadata:",
            "\t${2:namespace: ${3:default}",
            "\t}name: ${4:configmap-updater}",
            "rules:",
            "- apiGroups: [\"${5:}\"]",
            "\tresources: [\"${6:configmaps}\"]",
            "\tresourceNames: [\"${7:my-configmap}\"]",
            "\tverbs: [${8:\"update\", \"get\"}]"
        ],
        "prefix": [
            "role"
        ]
    },
    "pvolm": {
        "description": "Volume Mount and spec",
        "body": [
            "\tvolumeMounts:",
            "\t- name: ${1:volume}",
            "\t\tmountPath: ${2:/etc/mount/path}",
            "\t\t${3:subPath: ${4: key}}",
            "volumes:",
            "- name: $1",
            "\t${5:configMap}:",
            "\t\t${6:name}: ${7:someName}"
        ],
        "prefix": [
            "pvolm"
        ]
    },
    "sec": {
        "description": "Secret",
        "body": [
            "apiVersion: v1",
            "kind: Secret",
            "metadata:",
            "  name: ${1:secret-name}",
            "type: ${2:Opaque}",
            "data:",
            "  ${3:key}: ${4:value}"
        ],
        "prefix": [
            "sec"
        ]
    },
    "hpa": {
        "description": "Horizontal Pod Autoscaler",
        "body": [
            "apiVersion: autoscaling/v2beta1",
            "kind: HorizontalPodAutoscaler",
            "metadata:",
            "  name: ${1:hpa-name}",
            "  namespace: ${2:default}",
            "spec:",
            "  scaleTargetRef:",
            "    apiVersion: apps/v1",
            "    kind: Deployment",
            "    name: ${3:deployment-name}",
            "  minReplicas: 1",
            "  maxReplicas: 10",
            "  metrics:",
            "  - type: Resource",
            "    resource:",
            "      name: cpu",
            "      targetAverageUtilization: 10",
            "  - type: Resource",
            "    resource:",
            "    name: memory",
            "      targetAverageValue: 1000Mi"
        ],
        "prefix": [
            "hpa"
        ]
    },
    "aff": {
        "description": "Affinitiy/Anti-Affinity",
        "body": [
            "pod${1:Anti}Affinity:",
            "\t${2:preferred|required}DuringSchedulingIgnoredDuringExecution:",
            "\t- weight: 100",
            "\t\tpodAffinityTerm:",
            "\t\t\tlabelSelector:",
            "\t\t\t\tmatchExpressions:",
            "\t\t\t\t- key: ${3:app}",
            "\t\t\t\t\toperator: In",
            "\t\t\t\t\tvalues:",
            "\t\t\t\t\t- ${4:appname}",
            "\t\t\ttopologyKey: ${5:kubernetes.io/hostname}"
        ],
        "prefix": [
            "aff"
        ]
    },
    "ingtls": {
        "description": "Ingress TLS section",
        "body": [
            "tls:",
            "- secretName: ${2:$1.tls}",
            "\thosts:",
            "\t- ${1:host}"
        ],
        "prefix": [
            "ingtls"
        ]
    },
    "volm": {
        "description": "Volume Mount",
        "body": [
            "- name: ${1:volume}",
            "\tmountPath: ${2:/etc/mount/path}",
            "\t${3:subPath: ${4: key}}",
            "$0"
        ],
        "prefix": [
            "volm"
        ]
    },
    "depsvcing": {
        "description": "Deployment, service, and ingress",
        "body": [
            "apiVersion: apps/v1",
            "kind: Deployment",
            "metadata:",
            "\tname: ${1:some-controller}",
            "\tnamespace: ${2:default}",
            "spec:",
            "\treplicas: 1",
            "\tselector:",
            "\t\tmatchLabels:",
            "\t\t\t$3",
            "\ttemplate:",
            "\t\tmetadata:",
            "\t\t\tlabels:",
            "\t\t\t\t${3:app: $1}",
            "\t\tspec:",
            "\t\t\tcontainers:",
            "\t\t\t- name: ${4:name}",
            "\t\t\t\timage: ${5:nginx}",
            "\t\t\t\timagePullPolicy: Always",
            "\t\t\t\tresources:",
            "\t\t\t\t\trequests:",
            "\t\t\t\t\t\tcpu: 100m",
            "\t\t\t\t\t\tmemory: 200Mi",
            "\t\t\t\tports:",
            "\t\t\t\t- containerPort: ${6:8080}",
            "---",
            "apiVersion: v1",
            "kind: Service",
            "metadata:",
            "\tname: $1",
            "\tnamespace: $2",
            "spec:",
            "\tports:",
            "\t- port: ${7:80}",
            "\t\ttargetPort: $6",
            "\tselector:",
            "\t\t$3",
            "---",
            "apiVersion: extensions/v1beta1",
            "kind: Ingress",
            "metadata:",
            "\tname: $1",
            "\tnamespace: $2",
            "annotations:",
            "\tcert-manager.io/cluster-issuer: letsencrypt-prod",
            "\tkubernetes.io/ingress.class: nginx-external",
            "\tkubernetes.io/tls-acme: \"true\"",
            "\tnginx.ingress.kubernetes.io/ssl-passthrough: \"false\"",
            "spec:",
            "\t${10:tls:",
            "\t- secretName: ${9:$8.tls}",
            "\t\thosts:",
            "\t\t- $8",
            "\t}rules:",
            "\t- host: ${8:host}",
            "\t\thttp:",
            "\t\t\tpaths:",
            "\t\t\t- path: ${11:/}",
            "\t\t\t\tbackend:",
            "\t\t\t\t\tserviceName: $1",
            "\t\t\t\t\tservicePort: $7"
        ],
        "prefix": [
            "depsvcing"
        ]
    }
}
