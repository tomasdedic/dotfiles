{
"Deploy to Kubernetes": {
"prefix": "adoKubernetesManifest0",
"body": [
"- task: KubernetesManifest@0",
"  inputs:",
"    #action: # Options: 'bake', 'createSecret', 'delete', 'deploy', 'patch', 'promote', 'scale', 'reject' # Optional  # Choose the action to be performed.",
"    kubernetesServiceConnection: $1  # Required when action != bake  # Select a Kubernetes service connection.",
"    #namespace:  # Optional  # Sets the namespace for the commands by using the â€“namespace flag. If the namespace is not provided, the commands will run in the default namespace.",
"    #strategy: # Options: 'canary', 'none' # Optional  # Deployment strategy to be used",
"    #trafficSplitMethod: # Options: 'pod', 'smi' # Optional  # Traffic split method to be used",
"    percentage: $2  # Required when strategy = Canary && action = deploy  # Percentage of traffic redirect to canary deployment",
"    baselineAndCanaryReplicas: ${3:1}  # Required  # Baseline and canary replicas count",
"    manifests: $4  # Required when action = deploy || action = promote || action = reject  # Manifests to deploy",
"    #containers:  # Optional  # Containers",
"    #imagePullSecrets:  # Optional  # ImagePullSecret to pull image from private registry",
"    #renderType: # Options: 'helm', 'kompose', 'kustomize' # Optional  # Tool to use for generating manifest files.",
"    dockerComposeFile: $5  # Required when action = bake && renderType = kompose  # docker-compose file path",
"    helmChart: $6  # Required when action = bake && renderType = helm  # Helm chart path to bake",
"    #releaseName:  # Optional  # Helm release name to use",
"    #overrideFiles:  # Optional  # Override files to set",
"    #overrides:  # Optional  # Override values to set",
"    #kustomizationPath:  # Optional  # The argument must be the path to the directory containing the file, or a git repository URL with a path suffix specifying same with respect to the repository root.",
"    resourceToPatch: ${7:file} # Options: 'file', 'name' # Required  # to identify the resource",
"    resourceFileToPatch: $8  # Required when action = patch && resourceToPatch = file  # Path to the file used for patch",
"    kind: $9 # Options: 'deployment', 'replicaset', 'statefulset' # Required when action = scale || resourceToPatch = name  # Kind of K8s object; deployment, replicaSet etc.",
"    name: $10  # Required when action = scale || resourceToPatch = name  # Name of the k8s object",
"    replicas: $11  # Required when action = scale  # Number of replicas to scale to",
"    mergeStrategy: ${12:strategic} # Options: 'json', 'merge', 'strategic' # Required  # The type of patch being provided; one of [json merge strategic]",
"    #arguments:  # Optional  # Arguments for `kubectl delete` command",
"    patch: $13  # Required when action = patch  # Contents of patch",
"    secretType: ${14:dockerRegistry} # Options: 'dockerRegistry', 'generic' # Required  # Create/update a generic or docker imagepullsecret. Select dockerRegistry to create/update the imagepullsecret of the selected registry. An imagePullSecret is a way to pass a secret that contains a container registry password to the Kubelet so it can pull a private image on behalf of your Pod.",
"    #secretName:  # Optional  # Name of the secret. You can use this secret name in the Kubernetes YAML configuration file.",
"    #secretArguments:  # Optional  # Specify keys and literal values to insert in secret.For example, --from-literal=key1=value1 --from-literal=key2=\"top secret\".",
"    #dockerRegistryEndpoint:  # Optional  # Select a Docker registry service connection. Required for commands that need to authenticate with a registry.",
"    #rolloutStatusTimeout:  # Optional  # The length of time (in seconds) to wait before ending watch on rollout status",
"$15"
],
"description": "Use Kubernetes manifest files to deploy to clusters or even bake the manifest files to be used for deployments using Helm charts"
}
}
